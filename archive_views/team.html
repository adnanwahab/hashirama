<body class="gameprog">
  <header>
    <h1>2d Visibility</h1>
    <div class="subheading">
      from <a href="https://www.redblobgames.com/">Red Blob Games</a>
    </div>
    <nav>
      <search>
        <form action="https://www.google.com/search">
          <ul>
            <li><a href="https://www.redblobgames.com/">Home</a></li>
            <li><a href="https://www.redblobgames.com/blog/">Blog</a></li>
            <li><a href="https://pinboard.in/u:amitp/t:gamedev/">Links</a></li>
            <li><a href="https://twitter.com/redblobgames">Twitter</a></li>
            <li>
              <a rel="me" href="http://www-cs-students.stanford.edu/~amitp/"
                >About</a
              >
            </li>
            <li></li>
            <li>
              <input type="search" name="q" placeholder="Search" size="8" />
            </li>
          </ul>
          <input
            type="hidden"
            name="hq"
            value="site:www.redblobgames.com OR site:theory.stanford.edu/~amitp/ OR site:www-cs-students.stanford.edu/~amitp/ OR site:amitp.blogspot.com OR site:simblob.blogspot.com"
          />
        </form>
      </search>
    </nav>
  </header>
  <main>
    <address>June 2012, updated Mar 2018, Apr 2020</address>
    <section>
      <noscript
        >This page includes interactive diagrams that require your browser to
        have Canvas and Javascript enabled.</noscript
      >
      <div class="sidebyside">
        <div class="left">
          <p>
            In a 2D top-down map it is sometimes useful to calculate which areas
            are visible from a given point. For example you might want to hide
            what’s not visible from the player’s location, or you might want to
            know what areas would be lit by a torch.
          </p>
          <p>
            Drag the circle around to see what’s visible from the player’s
            location:
          </p>
        </div>
        <figure id="maze" class="right">
          <img
            class="placeholder"
            src="http://localhost:8000/static/js/static-lightmap.png?"
          />
        </figure>
      </div>
      <p>
        This algorithm can also calculate what areas are lit given a light
        source. Run once per light, we can build a light map showing which areas
        are lit up.
        <span id="maze-light-toggle"
          ><label
            ><input type="checkbox" id="maze-lights" />Show 24 lights added to
            the map.</label
          ></span
        >
      </p>
      <!-- - output is called isovist https://en.wikipedia.org/wiki/Isovist -->
      <p>
        The roguelike community has collected
        <a href="http://www.roguebasin.com/index.php?title=Field_of_Vision"
          >several algorithms</a
        ><sup class="print-endnote">[1]</sup>, especially for grids. See
        <a
          href="http://www.adammil.net/blog/v125_Roguelike_Vision_Algorithms.html"
          >this overview</a
        ><sup class="print-endnote">[2]</sup> for how grid algorithms handle
        situations differently. Also see
        <a href="https://www.albertford.com/shadowcasting/"
          >Albert Ford’s interactive tutorial about the recursive shadowcasting
          algorithm</a
        ><sup class="print-endnote">[3]</sup> (<a
          href="https://web.archive.org/web/20220816194637/https://www.albertford.com/shadowcasting/"
          >wayback archive</a
        ><sup class="print-endnote">[4]</sup> if the main link doesn’t work).
        <a
          href="https://www.gridbugs.org/visible-area-detection-recursive-shadowcast/"
          >Gridbugs has another nice explanation</a
        ><sup class="print-endnote">[5]</sup>.
      </p>
      <p>
        Subtractive algorithms start with everything visible then subtract the
        hidden areas; additive algorithms start with nothing visible then add
        the visible areas. I’ll describe an additive algorithm that works with
        line segments, not only solid blocks or grids.
      </p>
    </section>
    <section>
      <h2 id="ray-casting">
        <span><a href="#ray-casting">Ray casting</a></span
        ><a class="anchor" href="#ray-casting">#</a>
      </h2>
      <div class="sidebyside">
        <p class="left">
          A simple approach is to cast rays from the center. It’s a reasonable
          first step to get an approximate answer:
        </p>
        <figure id="diagram-raycast-interval" class="right"></figure>
      </div>
      <div class="sidebyside">
        <p class="left">
          To be smarter about it, let’s cast the rays only at angles where the
          walls begin or end. The triangles produced by these rays are the
          visible areas:
        </p>
        <figure id="diagram-raycast-endpoints" class="right"></figure>
      </div>
      <p>That’s it! The algorithm is:</p>
      <ol>
        <li>Calculate the angles where walls begin or end.</li>
        <li>Cast a ray from the center along each angle.</li>
        <li>Fill in the triangles generated by those rays.</li>
      </ol>
    </section>
    <section>
      <h2 id="wall-tracking">
        <span><a href="#wall-tracking">Wall tracking</a></span
        ><a class="anchor" href="#wall-tracking">#</a>
      </h2>
      <p>
        We could stop there, especially if we have a fast ray-casting algorithm
        that uses a spatial hash to avoid intersecting with every wall. However,
        a more efficient approach is to combine the ray casting and wall
        intersection into a single algorithm. I’ll describe here an algorithm
        that <em>sweeps a line around a circle</em>, hitting all the points
        sorted by angle; it’s also possible to <em>expand circles outwards</em>,
        hitting all the points sorted by radius, but I haven’t tried that
        approach.
      </p>
      <div class="sidebyside">
        <div class="left">
          <p>
            For the area between consecutive rays, we want to find the
            <em>nearest wall</em>. This wall is lit up; all others are hidden.
            Our strategy will be to <em>sweep</em> around 360° and process all
            of the wall endpoints. As we go, we’ll keep track of the walls that
            intersect the sweep line.
          </p>
          <p>Move the slider to make the sweep line pass the endpoints:</p>
        </div>
        <div class="right"><figure id="diagram-sweep-points"></figure></div>
      </div>
      <div class="sidebyside">
        <div class="left">
          <p>
            The next step is to keep track of which walls the sweep ray passes
            through. <em>Only the nearest wall is visible.</em> How do you
            figure out which wall is nearest? The simplest thing is to calculate
            the distance from the center to the wall. However, this approach
            doesn’t work well if the walls are of different sizes, so the demo
            uses a slightly more complicated approach, which I won’t explain
            here.
          </p>
          <p>
            Move the slider to sweep the angles with the nearest wall drawn in
            white and the other walls drawn in black.
          </p>
        </div>
        <div class="right"><figure id="diagram-sweep-segments"></figure></div>
      </div>
      <p>
        Whenever the nearest wall ends, or if a new wall is nearer than the
        others, we create a triangle showing a visible region. The union of
        these triangles is the area that is visible from the central point.
      </p>
      <p>
        Note that creating a triangle involves intersecting the previously
        active wall with the sweep ray. As a result, the new edge of the
        triangle may be longer or shorter than the sweep ray, and the far edge
        of the triangle may be shorter than the previously active wall.
      </p>
      <pre class="snippet">
var endpoints;   # list of endpoints, sorted by angle
var open = [];   # list of walls the sweep line intersects

loop over endpoints:
    remember which wall is nearest
    add any walls that BEGIN at this endpoint to 'walls'
    remove any walls that END at this endpoint from 'walls'

    figure out which wall is now nearest
    if the nearest wall changed:
        fill the current triangle and begin a new one</pre
      >
    </section>
    <section>
      <h2 id="playground">
        <span><a href="#playground">Playground</a></span
        ><a class="anchor" href="#playground">#</a>
      </h2>
      <div class="sidebyside">
        <p class="left">
          Here’s a playground with more blocks. Drag blocks into the grid area.
          Move the slider to see the sweep line in action, or drag the center
          point around to see what would be visible as the player walks around.
        </p>
        <div class="right"><figure id="diagram-playground"></figure></div>
      </div>
      <div id="haxe:trace"></div>
    </section>
    <section>
      <h2 id="combining-outputs">
        <span><a href="#combining-outputs">Combining outputs</a></span
        ><a class="anchor" href="#combining-outputs">#</a>
      </h2>
      <p>
        We can use set operations to combine outputs of this algorithm in
        interesting ways. These are implemented either as boolean operations in
        algorithms that analyze the output, or as bitmap operations in
        algorithms that render the output.
      </p>
      <h3><span>Player vision</span></h3>
      <p>
        The simplest operation is to limit the player’s vision by intersecting
        the output with the limit of visibility. For example, intersect the
        output of the algorithm with a circle to limit the radius you can see.
        Intersect with a gradient-filled circle to make the light fall off with
        distance. Intersect with a cone to build a “flashlight” effect that lets
        you see farther in front of you but not much behind you (see the trailer
        for
        <a href="https://www.youtube.com/watch?v=IHlHHLAIMx8&amp;t=35s"
          >Dynamite Jack</a
        ><sup class="print-endnote">[6]</sup> for an example of this).
      </p>
      <p>
        Player vision would also look better if it took into account both eyes
        instead of treating the player as a single point. I’d expect that you
        can take the union of the visibility output from each eye but I haven’t
        tried this.
      </p>
      <h3><span>Map objects</span></h3>
      <p>
        Visibility can also be used for calculating what areas a torch lights
        up. The demo at the top of the page first takes the union of the areas
        lit up by each torch, then intersects that with the area the player can
        see. (Note that this algorithm produces hard shadows and you’ll have to
        post-process the output to get soft shadows.)
      </p>
      <p>
        The same calculation could be used for determining what areas a security
        camera can see, what’s protected by a shield, or what’s magic objects
        are close enough to give you a bonus or curse.
      </p>
      <h3><span>AI behaviors</span></h3>
      <div class="sidebyside">
        <div class="left">
          <p>Visibility can also be used to build AI behaviors.</p>
          <p>
            For example, let’s suppose the enemy AI wants to throw a grenade to
            hit one of the players, but also wants to stand in a place where the
            players can’t shoot back. Grenades need to be close enough to hit
            the player, and also not behind an obstruction.
          </p>
          <p>
            This diagram shows the map annotations an AI unit might calculate:
          </p>
        </div>
        <div class="right"><figure id="grenade"></figure></div>
      </div>
      <p>
        Grenades thrown into purple areas will successfully hit a player. Orange
        and purple areas are dangerous to stand in; the player can shoot the AI
        unit from there. The AI needs to stand in a safe (dark blue) zone and
        throw a grenade into a purple zone, then take cover. How do you
        calculate cover? Run the visibility algorithm again from the place the
        AI plans to throw the grenade, making cabinets and tables block line of
        sight.
      </p>
    </section>
    <section>
      <h2 id="implementation">
        <span><a href="#implementation">Implementation</a></span
        ><a class="anchor" href="#implementation">#</a>
      </h2>
      <p>
        I have written a <a href="Visibility.hx">Haxe 3 implementation</a> of
        this algorithm, open source under the Apache v2 license (similar to MIT
        and BSD, it can be used in commercial projects).
        <a href="https://haxe.org/">Haxe</a
        ><sup class="print-endnote">[7]</sup> code can be compiled into
        Javascript, Actionscript, C++, Java, C#, or PHP. I compiled it into
        Javascript for this web page and compiled it into Flash for some of my
        other projects. I’ve compiled it into these languages:
      </p>
      <ul>
        <li>
          <a href="as3-version.zip">Actionscript</a>; readable, since
          Actionscript is not too different from Haxe
        </li>
        <li>
          <a href="output/_visibility.js">Javascript</a> (used for the demos on
          this page); mostly readable.
        </li>
        <li>
          <a href="https://github.com/Silverwolf90/2d-visibility">Javascript</a
          ><sup class="print-endnote">[8]</sup> ported by hand by Cyril
          Silverman; more readable than the one compiled from Haxe.
        </li>
        <li>
          <a href="java-version.zip">Java</a>; mildly readable but not great.
        </li>
        <li>
          <a href="csharp-version.zip">C#</a>; mildly readable but not great.
          Roy Triesscheijn has a better version
          <a
            href="https://roy-t.nl/2014/02/27/2d-lighting-and-shadows-preview.html"
            >here</a
          ><sup class="print-endnote">[9]</sup>.
        </li>
        <li>
          <a href="https://github.com/fahall/godot_2d_visibility"
            >Alex Hall has a GDscript version</a
          ><sup class="print-endnote">[10]</sup>.
        </li>
        <li>
          <a href="https://github.com/akapkotel/light_raycasting"
            >R. Trabski has a Python version</a
          ><sup class="print-endnote">[11]</sup>.
        </li>
      </ul>
      <p>
        Wade Tritschler suggests
        <a
          href="https://www.redblobgames.com/articles/visibility/#comment-850486470"
          >porting by hand</a
        ><sup class="print-endnote">[12]</sup> is going to generate cleaner
        results than using the Haxe output. I agree. You’ll also understand the
        algorithm better if you convert the code by hand.
      </p>
      <p>
        Warning: <strong>my implementation is mediocre</strong>. It is missing
        optimizations and it has numerical robustness issues. It generates
        superfluous empty triangles in the output.
        <a href="https://github.com/mikolalysenko/robust-arithmetic-notes"
          >This page</a
        ><sup class="print-endnote">[13]</sup> is worth a read, and take a look
        at
        <a href="https://github.com/mourner/robust-predicates">this library</a
        ><sup class="print-endnote">[14]</sup> which implements robust
        algorithms. Another reference is
        <a href="http://www.cs.cmu.edu/~quake/robust.html">Shewchuk’s</a
        ><sup class="print-endnote">[15]</sup>. Thash posted in the comments a
        <a href="https://github.com/trylock/visibility">C++ version</a
        ><sup class="print-endnote">[16]</sup> that also handles the tricky
        cases.
      </p>
      <p>
        There’s a similar algorithm
        <a href="https://doc.cgal.org/latest/Visibility_2/">in CGAL</a
        ><sup class="print-endnote">[17]</sup> (C++). See
        <a
          href="https://github.com/CGAL/cgal/blob/master/Visibility_2/include/CGAL/Rotational_sweep_visibility_2.h"
          >Rotational_sweep_visibility</a
        ><sup class="print-endnote">[18]</sup>. There’s a Python version
        <a
          href="https://scikit-geometry.github.io/scikit-geometry/arrangements_visibility.html#Computing-Visibility"
          >in SciKit</a
        ><sup class="print-endnote">[19]</sup>.
      </p>
      <p>
        Although the main part of the algorithm is CPU bound, the GPU could be
        used for triangle rendering to a bitmap and compositing operations for
        combining bitmap outputs. (A boolean AND operation becomes a bitmap
        multiply; a boolean OR becomes a bitmap add and clamp.) The performance
        hasn’t been enough of a problem in my projects so I haven’t built a GPU
        version. If your game is CPU bound, consider using a subtractive
        algorithm (instead of the additive one shown here), rendering the shadow
        of each line segment as a quad. It will increase the rendering load on
        the GPU but it doesn’t require sorting on the CPU. If fill rate is an
        issue, consider rendering a light bitmap that’s at a lower resolution
        than the game screen, and scaling it up. Also consider a 1D shadow map
        (<a
          href="https://www.gamedeveloper.com/programming/fast-2d-shadows-in-unity-using-1d-shadow-mapping"
          >here</a
        ><sup class="print-endnote">[20]</sup>, or
        <a
          href="https://github.com/mattdesl/lwjgl-basics/wiki/2D-Pixel-Perfect-Shadows"
          >here</a
        ><sup class="print-endnote">[21]</sup>).
      </p>
    </section>
    <section>
      <h2 id="references">
        <span><a href="#references">References</a></span
        ><a class="anchor" href="#references">#</a>
      </h2>
      <ol>
        <li>
          <a
            href="https://scholar.google.com/scholar?cluster=7815126113820798295"
            >Asano, Tetsuo. “An efficient algorithm for finding the visibility
            polygon for a polygonal region with holes.”</a
          ><sup class="print-endnote">[22]</sup> IEICE TRANSACTIONS (1976-1990)
          68.9 (1985): 557-559. This is a
          <a href="https://en.wikipedia.org/wiki/Sweep_line_algorithm"
            >sweep algorithm</a
          ><sup class="print-endnote">[23]</sup> like I’m using on this page,
          applied to polar coordinates instead of cartesian coordinates. This
          seems to be the paper that introduced the algorithm but I can’t find
          the paper online.
        </li>
        <li>
          <a
            href="https://scholar.google.com/scholar?cluster=11179288360296920832"
            >Bungiu, Francisc, et al. “Efficient computation of visibility
            polygons.”</a
          ><sup class="print-endnote">[24]</sup> arXiv preprint arXiv:1403.3905
          (2014). This paper covers several algorithms, including one that’s
          significantly faster than the one I’m using on this page. This paper
          came out after I wrote my page; I’d like to one day go back and try
          their algorithm. The faster algorithm is implemented
          <a href="https://doc.cgal.org/latest/Visibility_2/">in CGAL</a
          ><sup class="print-endnote">[25]</sup>, which measured it as
          <b>50X faster</b> than the rotational sweep algorithm I have on this
          page. This fast algorithm may be related to
          <a href="http://sadumbrella.blogspot.com/2010/11/beamcasting.html"
            >this beamcasting approach</a
          ><sup class="print-endnote">[26]</sup>, which was published in 2010 on
          a blog.
        </li>
      </ol>
    </section>
    <section>
      <h2 id="more">
        <span><a href="#more">Related</a></span
        ><a class="anchor" href="#more">#</a>
      </h2>
      <p>
        <a href="https://ncase.me/sight-and-light/"
          >Nicky Case’s Sight and Light</a
        ><sup class="print-endnote">[27]</sup> uses the same algorithm to solve
        the visibility problem.
        <a href="https://legends2k.github.io/2d-fov/"
          >Sundaram Ramaswamy’s page</a
        ><sup class="print-endnote">[28]</sup> covers visibility with arcs
        instead of circles, and includes a detailed explanation of the algorithm
        and implementation.
        <a href="https://simblob.blogspot.com/2012/07/2d-visibility.html"
          >My blog post</a
        ><sup class="print-endnote">[29]</sup> has more links to projects like
        this. Munificent covers
        <a
          href="http://journal.stuffwithstuff.com/2015/09/07/what-the-hero-sees/"
          >visibility algorithms optimized for grids</a
        ><sup class="print-endnote">[30]</sup>, with interactive diagrams and
        sample code. Kevin Zuniga has a
        <a
          href="https://github.com/kevinzg/visimerge/blob/notebook/notebook/VisibilityRegionsMerge.ipynb"
          >divide-and-conquer approach</a
        ><sup class="print-endnote">[31]</sup> with a parallel implementation in
        CUDA.
        <a
          href="https://web.archive.org/web/20140906102155/https://briangordon.github.io/2014/08/the-skyline-problem.html"
          >The Skyline Problem</a
        ><sup class="print-endnote">[32]</sup> is similar to 2d visibility,
        except it’s in cartesian coordinates instead of polar coordinates.
        There’s also the
        <a href="https://en.wikipedia.org/wiki/Art_gallery_problem"
          >art gallery problem</a
        ><sup class="print-endnote">[33]</sup> about placing multiple guards in
        the environment so that they can see the every area of the map. I’m
        making a list on Notion of
        <a
          href="https://www.notion.so/redblobgames/f8bc2f44fba94607afa9c06711d23245?v=0766432cb1534ce582ce35b33cbbef7e&amp;p=b9752fb674dd48f9af30e6d96073de01"
          >possible future updates to this page</a
        ><sup class="print-endnote">[34]</sup>.
      </p>
      <!-- other impl: steve ruiz typescript https://gist.github.com/steveruizok/a6900d9db1ed59179f218e0fcef66a6a  --><!-- other impl: Java https://code.google.com/p/straightedge/ --><!-- other impl: JS https://github.com/byronknoll/visibility-polygon-js --><!-- other impl: https://github.com/miyu/OpenMOBA/blob/master/OpenMOBA/Geometry/VisibilityPolygon.cs#L444 , uses cross product for segment-segment comparison -->
    </section>
  </main>
  <div class="below-divider">
    <p>
      Email me
      <a class="email" rel="me" href="mailto:redblobgames@gmail.com"
        >redblobgames@gmail.com</a
      >, or tweet
      <a rel="me" href="https://twitter.com/redblobgames">@redblobgames</a>, or
      comment:
    </p>
    <div class="print-endnote">
      <h3>Endnotes</h3>
      <ol>
        <li>[1]: http://www.roguebasin.com/index.php?title=Field_of_Vision</li>
        <li>
          [2]: http://www.adammil.net/blog/v125_Roguelike_Vision_Algorithms.html
        </li>
        <li>[3]: https://www.albertford.com/shadowcasting/</li>
        <li>
          [4]:
          https://web.archive.org/web/20220816194637/https://www.albertford.com/shadowcasting/
        </li>
        <li>
          [5]:
          https://www.gridbugs.org/visible-area-detection-recursive-shadowcast/
        </li>
        <li>[6]: https://www.youtube.com/watch?v=IHlHHLAIMx8&amp;t=35s</li>
        <li>[7]: https://haxe.org/</li>
        <li>[8]: https://github.com/Silverwolf90/2d-visibility</li>
        <li>
          [9]: https://roy-t.nl/2014/02/27/2d-lighting-and-shadows-preview.html
        </li>
        <li>[10]: https://github.com/fahall/godot_2d_visibility</li>
        <li>[11]: https://github.com/akapkotel/light_raycasting</li>
        <li>
          [12]:
          https://www.redblobgames.com/articles/visibility/#comment-850486470
        </li>
        <li>[13]: https://github.com/mikolalysenko/robust-arithmetic-notes</li>
        <li>[14]: https://github.com/mourner/robust-predicates</li>
        <li>[15]: http://www.cs.cmu.edu/~quake/robust.html</li>
        <li>[16]: https://github.com/trylock/visibility</li>
        <li>[17]: https://doc.cgal.org/latest/Visibility_2/</li>
        <li>
          [18]:
          https://github.com/CGAL/cgal/blob/master/Visibility_2/include/CGAL/Rotational_sweep_visibility_2.h
        </li>
        <li>
          [19]:
          https://scikit-geometry.github.io/scikit-geometry/arrangements_visibility.html#Computing-Visibility
        </li>
        <li>
          [20]:
          https://www.gamedeveloper.com/programming/fast-2d-shadows-in-unity-using-1d-shadow-mapping
        </li>
        <li>
          [21]:
          https://github.com/mattdesl/lwjgl-basics/wiki/2D-Pixel-Perfect-Shadows
        </li>
        <li>
          [22]: https://scholar.google.com/scholar?cluster=7815126113820798295
        </li>
        <li>[23]: https://en.wikipedia.org/wiki/Sweep_line_algorithm</li>
        <li>
          [24]: https://scholar.google.com/scholar?cluster=11179288360296920832
        </li>
        <li>[25]: https://doc.cgal.org/latest/Visibility_2/</li>
        <li>[26]: http://sadumbrella.blogspot.com/2010/11/beamcasting.html</li>
        <li>[27]: https://ncase.me/sight-and-light/</li>
        <li>[28]: https://legends2k.github.io/2d-fov/</li>
        <li>[29]: https://simblob.blogspot.com/2012/07/2d-visibility.html</li>
        <li>
          [30]: http://journal.stuffwithstuff.com/2015/09/07/what-the-hero-sees/
        </li>
        <li>
          [31]:
          https://github.com/kevinzg/visimerge/blob/notebook/notebook/VisibilityRegionsMerge.ipynb
        </li>
        <li>
          [32]:
          https://web.archive.org/web/20140906102155/https://briangordon.github.io/2014/08/the-skyline-problem.html
        </li>
        <li>[33]: https://en.wikipedia.org/wiki/Art_gallery_problem</li>
        <li>
          [34]:
          https://www.notion.so/redblobgames/f8bc2f44fba94607afa9c06711d23245?v=0766432cb1534ce582ce35b33cbbef7e&amp;p=b9752fb674dd48f9af30e6d96073de01
        </li>
      </ol>
    </div>
    <div class="comments" role="complementary">
      <div id="disqus_thread">
        <button style="padding: 1em; width: 100%" onclick="$disqus()">
          Load comments
        </button>
      </div>
      <script>

        else if('IntersectionObserver' in window){new IntersectionObserver(e=>{if(e[0].isIntersecting)$disqus()}).observe(document.getElementById('disqus_thread'))}
      </script>
      <noscript
        ><a
          href="https://redblobgames.disqus.com/?url=https://www.redblobgames.com/articles/visibility/"
          >View the discussion thread.</a
        ></noscript
      >
    </div>
  </div>
  <footer>
    <div>
      <address>
        Copyright © 2024
        <a rel="author home copyright" href="https://www.redblobgames.com/"
          >Red Blob Games</a
        ><br /><a href="https://www.redblobgames.com/blog/posts.xml"
          ><svg viewBox="0 0 30 30" height="0.8em">
            <rect width="30" height="30" rx="5" fill="orange"></rect>
            <circle cx="7" cy="23" r="4" fill="white"></circle>
            <path
              d="M 5,5 A 20,20,0,0,1,25,25 M 5,13 A 12,12,0,0,1,17,25"
              fill="none"
              stroke="white"
              stroke-width="4"
              stroke-linecap="square"
            ></path></svg
          >RSS Feed</a
        >
      </address>
      <div>
        <script
          type="text/javascript"
          src="/js/draggable.v1.js?2018-12-23-11-36-05"
        ></script>
        <script
          type="text/javascript"
          src="output/_visibility.js?2014-08-24-10-16-15"
        ></script>
        <script
          type="text/javascript"
          src="visibility-ui.js?2024-04-23-20-20-44"
        ></script>
        Created 13 Mar 2012 with
        <a href="https://en.wikipedia.org/wiki/Haxe">Haxe</a>;
        <!-- Created: 13 Mar 2012 --><!-- hhmts start -->Last modified: 29 Dec
        2023<!-- hhmts end -->
      </div>
    </div>
  </footer>
  <script src="http://localhost:8000/static/js/_visibility.js"></script>
  <script src="http://localhost:8000/static/js/_visibility-ui.js"></script>
</body>
