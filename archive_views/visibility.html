<body class="gameprog">
  <style>
    span,
    a,
    p {
      display: none;
    }
  </style>
  <main>
    <section>
      <div class="sidebyside">
        <!-- <div class="left">
          <p>
            In a 2D top-down map it is sometimes useful to calculate which areas
            are visible from a given point. For example you might want to hide
            what’s not visible from the player’s location, or you might want to
            know what areas would be lit by a torch.
          </p>
          <p>
            Drag the circle around to see what’s visible from the player’s
            location:
          </p>
        </div> -->
        <figure id="maze" class="right">
          <img
            class="placeholder"
            src="http://localhost:8000/static/js/static-lightmap.png?"
          />
        </figure>
      </div>
      <!-- <p>
        This algorithm can also calculate what areas are lit given a light
        source. Run once per light, we can build a light map showing which areas
        are lit up.
        <span id="maze-light-toggle"
          ><label
            ><input type="checkbox" id="maze-lights" />Show 24 lights added to
            the map.</label
          ></span
        >
      </p> -->
      <!-- - output is called isovist https://en.wikipedia.org/wiki/Isovist -->
      <!-- <p>
        The roguelike community has collected
        <a href="http://www.roguebasin.com/index.php?title=Field_of_Vision"
          >several algorithms</a
        ><sup class="print-endnote">[1]</sup>, especially for grids. See
        <a
          href="http://www.adammil.net/blog/v125_Roguelike_Vision_Algorithms.html"
          >this overview</a
        ><sup class="print-endnote">[2]</sup> for how grid algorithms handle
        situations differently. Also see
        <a href="https://www.albertford.com/shadowcasting/"
          >Albert Ford’s interactive tutorial about the recursive shadowcasting
          algorithm</a
        ><sup class="print-endnote">[3]</sup> (<a
          href="https://web.archive.org/web/20220816194637/https://www.albertford.com/shadowcasting/"
          >wayback archive</a
        ><sup class="print-endnote">[4]</sup> if the main link doesn’t work).
        <a
          href="https://www.gridbugs.org/visible-area-detection-recursive-shadowcast/"
          >Gridbugs has another nice explanation</a
        ><sup class="print-endnote">[5]</sup>.
      </p> -->
      <p>
        Subtractive algorithms start with everything visible then subtract the
        hidden areas; additive algorithms start with nothing visible then add
        the visible areas. I’ll describe an additive algorithm that works with
        line segments, not only solid blocks or grids.
      </p>
    </section>
    <section>
      <h2 id="ray-casting">
        <span><a href="#ray-casting">Ray casting</a></span
        ><a class="anchor" href="#ray-casting">#</a>
      </h2>
      <div class="sidebyside">
        <p class="left">
          A simple approach is to cast rays from the center. It’s a reasonable
          first step to get an approximate answer:
        </p>
        <figure id="diagram-raycast-interval" class="right"></figure>
      </div>
      <div class="sidebyside">
        <p class="left">
          To be smarter about it, let’s cast the rays only at angles where the
          walls begin or end. The triangles produced by these rays are the
          visible areas:
        </p>
        <figure id="diagram-raycast-endpoints" class="right"></figure>
      </div>
      <p>That’s it! The algorithm is:</p>
      <ol>
        <li>Calculate the angles where walls begin or end.</li>
        <li>Cast a ray from the center along each angle.</li>
        <li>Fill in the triangles generated by those rays.</li>
      </ol>
    </section>
    <section>
      <h2 id="wall-tracking">
        <span><a href="#wall-tracking">Wall tracking</a></span
        ><a class="anchor" href="#wall-tracking">#</a>
      </h2>
      <p>
        We could stop there, especially if we have a fast ray-casting algorithm
        that uses a spatial hash to avoid intersecting with every wall. However,
        a more efficient approach is to combine the ray casting and wall
        intersection into a single algorithm. I’ll describe here an algorithm
        that <em>sweeps a line around a circle</em>, hitting all the points
        sorted by angle; it’s also possible to <em>expand circles outwards</em>,
        hitting all the points sorted by radius, but I haven’t tried that
        approach.
      </p>
      <div class="sidebyside">
        <div class="left">
          <p>
            For the area between consecutive rays, we want to find the
            <em>nearest wall</em>. This wall is lit up; all others are hidden.
            Our strategy will be to <em>sweep</em> around 360° and process all
            of the wall endpoints. As we go, we’ll keep track of the walls that
            intersect the sweep line.
          </p>
          <p>Move the slider to make the sweep line pass the endpoints:</p>
        </div>
        <div class="right"><figure id="diagram-sweep-points"></figure></div>
      </div>
      <div class="sidebyside">
        <div class="left">
          <p>
            The next step is to keep track of which walls the sweep ray passes
            through. <em>Only the nearest wall is visible.</em> How do you
            figure out which wall is nearest? The simplest thing is to calculate
            the distance from the center to the wall. However, this approach
            doesn’t work well if the walls are of different sizes, so the demo
            uses a slightly more complicated approach, which I won’t explain
            here.
          </p>
          <p>
            Move the slider to sweep the angles with the nearest wall drawn in
            white and the other walls drawn in black.
          </p>
        </div>
        <div class="right"><figure id="diagram-sweep-segments"></figure></div>
      </div>
      <p>
        Whenever the nearest wall ends, or if a new wall is nearer than the
        others, we create a triangle showing a visible region. The union of
        these triangles is the area that is visible from the central point.
      </p>
      <p>
        Note that creating a triangle involves intersecting the previously
        active wall with the sweep ray. As a result, the new edge of the
        triangle may be longer or shorter than the sweep ray, and the far edge
        of the triangle may be shorter than the previously active wall.
      </p>
      <pre class="snippet">
var endpoints;   # list of endpoints, sorted by angle
var open = [];   # list of walls the sweep line intersects

loop over endpoints:
    remember which wall is nearest
    add any walls that BEGIN at this endpoint to 'walls'
    remove any walls that END at this endpoint from 'walls'

    figure out which wall is now nearest
    if the nearest wall changed:
        fill the current triangle and begin a new one</pre
      >
    </section>
    <section>
      <h2 id="playground">
        <span><a href="#playground">Playground</a></span
        ><a class="anchor" href="#playground">#</a>
      </h2>
      <div class="sidebyside">
        <p class="left">
          Here’s a playground with more blocks. Drag blocks into the grid area.
          Move the slider to see the sweep line in action, or drag the center
          point around to see what would be visible as the player walks around.
        </p>
        <div class="right"><figure id="diagram-playground"></figure></div>
      </div>
      <div id="haxe:trace"></div>
    </section>
    <section>
      <h2 id="combining-outputs">
        <span><a href="#combining-outputs">Combining outputs</a></span
        ><a class="anchor" href="#combining-outputs">#</a>
      </h2>
      <p>
        We can use set operations to combine outputs of this algorithm in
        interesting ways. These are implemented either as boolean operations in
        algorithms that analyze the output, or as bitmap operations in
        algorithms that render the output.
      </p>
      <h3><span>Player vision</span></h3>
      <p>
        The simplest operation is to limit the player’s vision by intersecting
        the output with the limit of visibility. For example, intersect the
        output of the algorithm with a circle to limit the radius you can see.
        Intersect with a gradient-filled circle to make the light fall off with
        distance. Intersect with a cone to build a “flashlight” effect that lets
        you see farther in front of you but not much behind you (see the trailer
        for
        <a href="https://www.youtube.com/watch?v=IHlHHLAIMx8&amp;t=35s"
          >Dynamite Jack</a
        ><sup class="print-endnote">[6]</sup> for an example of this).
      </p>
      <p>
        Player vision would also look better if it took into account both eyes
        instead of treating the player as a single point. I’d expect that you
        can take the union of the visibility output from each eye but I haven’t
        tried this.
      </p>
      <h3><span>Map objects</span></h3>
      <p>
        Visibility can also be used for calculating what areas a torch lights
        up. The demo at the top of the page first takes the union of the areas
        lit up by each torch, then intersects that with the area the player can
        see. (Note that this algorithm produces hard shadows and you’ll have to
        post-process the output to get soft shadows.)
      </p>
      <p>
        The same calculation could be used for determining what areas a security
        camera can see, what’s protected by a shield, or what’s magic objects
        are close enough to give you a bonus or curse.
      </p>
      <h3><span>AI behaviors</span></h3>
      <div class="sidebyside">
        <div class="left">
          <p>Visibility can also be used to build AI behaviors.</p>
          <p>
            For example, let’s suppose the enemy AI wants to throw a grenade to
            hit one of the players, but also wants to stand in a place where the
            players can’t shoot back. Grenades need to be close enough to hit
            the player, and also not behind an obstruction.
          </p>
          <p>
            This diagram shows the map annotations an AI unit might calculate:
          </p>
        </div>
        <div class="right"><figure id="grenade"></figure></div>
      </div>
      <p>
        Grenades thrown into purple areas will successfully hit a player. Orange
        and purple areas are dangerous to stand in; the player can shoot the AI
        unit from there. The AI needs to stand in a safe (dark blue) zone and
        throw a grenade into a purple zone, then take cover. How do you
        calculate cover? Run the visibility algorithm again from the place the
        AI plans to throw the grenade, making cabinets and tables block line of
        sight.
      </p>
    </section>

    <section>
      <!-- <p>
        <a href="https://ncase.me/sight-and-light/"
          >Nicky Case’s Sight and Light</a
        ><sup class="print-endnote">[27]</sup> uses the same algorithm to solve
        the visibility problem.
        <a href="https://legends2k.github.io/2d-fov/"
          >Sundaram Ramaswamy’s page</a
        ><sup class="print-endnote">[28]</sup> covers visibility with arcs
        instead of circles, and includes a detailed explanation of the algorithm
        and implementation.
        <a href="https://simblob.blogspot.com/2012/07/2d-visibility.html"
          >My blog post</a
        ><sup class="print-endnote">[29]</sup> has more links to projects like
        this. Munificent covers
        <a
          href="http://journal.stuffwithstuff.com/2015/09/07/what-the-hero-sees/"
          >visibility algorithms optimized for grids</a
        ><sup class="print-endnote">[30]</sup>, with interactive diagrams and
        sample code. Kevin Zuniga has a
        <a
          href="https://github.com/kevinzg/visimerge/blob/notebook/notebook/VisibilityRegionsMerge.ipynb"
          >divide-and-conquer approach</a
        ><sup class="print-endnote">[31]</sup> with a parallel implementation in
        CUDA.
        <a
          href="https://web.archive.org/web/20140906102155/https://briangordon.github.io/2014/08/the-skyline-problem.html"
          >The Skyline Problem</a
        ><sup class="print-endnote">[32]</sup> is similar to 2d visibility,
        except it’s in cartesian coordinates instead of polar coordinates.
        There’s also the
        <a href="https://en.wikipedia.org/wiki/Art_gallery_problem"
          >art gallery problem</a
        ><sup class="print-endnote">[33]</sup> about placing multiple guards in
        the environment so that they can see the every area of the map. I’m
        making a list on Notion of
        <a
          href="https://www.notion.so/redblobgames/f8bc2f44fba94607afa9c06711d23245?v=0766432cb1534ce582ce35b33cbbef7e&amp;p=b9752fb674dd48f9af30e6d96073de01"
          >possible future updates to this page</a
        ><sup class="print-endnote">[34]</sup>.
      </p> -->
      <!-- other impl: steve ruiz typescript https://gist.github.com/steveruizok/a6900d9db1ed59179f218e0fcef66a6a  --><!-- other impl: Java https://code.google.com/p/straightedge/ --><!-- other impl: JS https://github.com/byronknoll/visibility-polygon-js --><!-- other impl: https://github.com/miyu/OpenMOBA/blob/master/OpenMOBA/Geometry/VisibilityPolygon.cs#L444 , uses cross product for segment-segment comparison -->
    </section>
  </main>

  <script src="http://localhost:8000/static/js/draggable.v1.js"></script>

  <script src="http://localhost:8000/static/js/_visibility.js"></script>
  <script src="http://localhost:8000/static/js/visibility-ui.js"></script>
</body>
